vhat <- vcov(m)
diag(vhat)
str(vhat)
plot(vhat)
image(vhat)
diag(vhat)
bdiag(vhat)
?diag
?Matrix
diag(vhat)
dim(vhat)
diag(vhat)
str(vhat)
str(vhat@x)
as.matrix(vhat)
diag(as.matrix(vhat))
source('~/Dropbox/UZH/Forschung/CDM/GitHub/Rcdm/R/gdina.R')
vhat <- vcov(m)
diag(vhat)
sqrt(diag(vhat))
vhat <- vcov(m, type = "partial")
sqrt(diag(vhat))
vhat <- vcov(m, type = "itemwise")
sqrt(diag(vhat))
source('~/Dropbox/UZH/Forschung/CDM/GitHub/Rcdm/R/gdina.R')
coef(m)
m <- gdina(resp, qmat)
coef(m)
vhat <- vcov(m)
sqrt(diag(vhat))
vhat <- vcov(m, type = "partial") # ignore skill parameters
sqrt(diag(vhat))
vhat <- vcov(m, type = "itemwise") # itemwise
sqrt(diag(vhat))
vhat
colnames(vhat)
confint(m)
confint(m, alpha = 0.05)
plot(m)
plot(m)
x11()
plot(m)
plot(m)
x11()
plot(m)
loglik(m)
logLik(m)
BIC(m)
AIC(m)
m <- gdina(resp, qmat, rule = "DINA")
m1 <- gdina(resp, qmat, rule = "DINA")
mDINA <- gdina(resp, qmat, rule = "DINA")
plot(mDINA)
x11()
plot(mDINA)
mACDM <- gdina(resp, qmat, rule = "ACDM")
mACDM <- gdina(resp, qmat, rule = "A-CDM")
plot(mACDM)
source('~/Dropbox/UZH/Forschung/CDM/GitHub/Rcdm/R/gdina.R')
mACDM <- gdina(resp, qmat, rule = "ACDM")
plot(mACDM)
anova(mDINA, mACDM, m)
mACDM <- gdina(resp, qmat, rule = "ACDM")
plot(mACDM)
anova(mDINA, mACDM, m)
mDINA <- gdina(resp, qmat, rule = "DINA")
anova(mDINA, mACDM, m)
x11()
plot(mACDM)
mACDM$prep$rule
m <- gdina(resp, qmat)
mDINA <- gdina(resp, qmat, rule = "DINA")
plot(mDINA)
mDINO <- gdina(resp, qmat, rule = "DINO")
mACDM <- gdina(resp, qmat, rule = "ACDM")
anova(mDINA, mACDM, m)
anova(mDINA, mDINO., mACDM, m)
BIC(mDINA, mDINO, mACDM, m)
AIC(mDINA, mDINO, mACDM, m)
mGDINA <- gdina(resp, qmat)
anova(mDINA, mACDM, mGDINA)
AIC(mDINA, mDINO, mACDM, mGDINA)
BIC(mDINA, mDINO, mACDM, mGDINA)
anova(mDINA, mACDM, mGDINA)
coef(mGDINA, full = TRUE)
mGDINA$pj
confint(mGDINA)
confint(mGDINA, prob = TRUE)
gdina_wald(mGDINA)
gdina_wald(mGDINA)
qmat <- read.table(header = TRUE, text = "
cp id pb un
0  0  1  0
1  0  0  0
0  0  0  1
0  1  0  0
1  0  1  0
1  0  1  0
0  0  1  1
0  0  1  1
0  1  1  0
1  1  0  0
1  1  1  0
0  1  1  1
")
rownames(qmat) <- colnames(resp)
qmat```
qmat
t(qmat)
qmat <- t(read.table(header = TRUE, text = "
cp    0    1    0    0    1    1    0    0    0    1    1    0
id    0    0    0    1    0    0    0    0    1    1    1    1
pb    1    0    0    0    1    1    1    1    1    0    1    1
un    0    0    1    0    0    0    1    1    0    0    0    1
"))
qmat
qmat <- t(read.table(header = FALSE, text = "
cp    0    1    0    0    1    1    0    0    0    1    1    0
id    0    0    0    1    0    0    0    0    1    1    1    1
pb    1    0    0    0    1    1    1    1    1    0    1    1
un    0    0    1    0    0    0    1    1    0    0    0    1
"))
qmat <- t(read.table(header = FALSE, text = "
0    1    0    0    1    1    0    0    0    1    1    0
0    0    0    1    0    0    0    0    1    1    1    1
1    0    0    0    1    1    1    1    1    0    1    1
0    0    1    0    0    0    1    1    0    0    0    1
"))
colnames(qmat) <- c("cp", "id", "pb", "un")
rownames(qmat) <- colnames(resp)
mGDINA$pa
mGDINA$pj
source('~/Dropbox/UZH/Forschung/CDM/GitHub/Rcdm/R/gdina.R')
mGDINA <- gdina(resp, qmat)
mGDINA$dj
mGDINA$dj
coef(mGDINA)
source('~/Dropbox/UZH/Forschung/CDM/GitHub/Rcdm/R/gdina.R')
mGDINA <- gdina(resp, qmat)
source('~/Dropbox/UZH/Forschung/CDM/GitHub/Rcdm/R/gdina.R')
mGDINA <- gdina(resp, qmat)
coef(mGDINA)
head(coef(mGDINA)()
head(coef(mGDINA))
head(coef(mGDINA))
v <- vcov(mGDINA, type = "partial") # ignore skill parameters
sqrt(diag(v))
v <- vcov(mGDINA, type = "partial") # ignore skill parameters
sqrt(diag(v))
v <- vcov(mGDINA, type = "partial") # ignore skill parameters
sqrt(diag(v))
v <- vcov(mGDINA, type = "partial") # ignore skill parameters
sqrt(diag(v))
v <- vcov(mGDINA, type = "itemwise") # itemwise
sqrt(diag(v))
source('~/Dropbox/UZH/Forschung/CDM/GitHub/Rcdm/R/gdina.R')
source('~/Dropbox/UZH/Forschung/CDM/GitHub/Rcdm/R/gdina.R')
library("Rcdm")
library("Rcdm")
data("probability", package = "pks")
items <- sprintf("b1%.2i", 1:12)
resp <- probability[, items]
resp <- resp[complete.cases(resp),]
qmat <- read.table(header = TRUE, text = "
cp id pb un
0  0  1  0
1  0  0  0
0  0  0  1
0  1  0  0
1  0  1  0
1  0  1  0
0  0  1  1
0  0  1  1
0  1  1  0
1  1  0  0
1  1  1  0
0  1  1  1
")
rownames(qmat) <- colnames(resp)
## fit model
mGDINA <- gdina(resp, qmat)
mACDM <- gdina(resp, qmat, rule = "ACDM")
mGDINA
mGDINA$dj
unlist(mGDINA$dj)
mGDINA$dj
mGDINA$pj
mACDM$pj
mGDINA$pj$b112
mACDM$pj$b112
mGDINA$pj$b111
mACDM$pj$b111
mACDM$prep$Aj
mACDM$prep$Mj
mGDINA$prep$Mj
mACDM$prep$Mj
mGDINA$prep$Mj
mGDINA$prep$Mj$b112
mACDM$prep$Mj$b112
xx <- gdina_sim(1000, qmat, rule = "G-DINA")
gdina(xx, qmat)$loglik
gdina(xx, qmat, rule = "ACDM")$loglik
gdina(xx$resp, qmat)$loglik
gdina(xx$resp, qmat, rule = "ACDM")$loglik
mGDINA <- gdina(xx$resp, qmat)$loglik
nACDM <- gdina(xx$resp, qmat, rule = "ACDM")$loglik
mGDINA <- gdina(xx$resp, qmat)
mACDM <- gdina(xx$resp, qmat, rule = "ACDM")
mGDINA$loglik
mACDM$loglik
x <- xx$resp
q <- qmat
rule <- "G-DINA"
link = "identity"
ctrl = gdina_control()
link <- match.arg(link, c("identity", "log", "logit"))
linkfn <- switch(link,
"identity" = function(x) x,
"log" = log,
"logit" = qlogis)
invlinkfn <- switch(link,
"identity" = function(x) x,
"log" = exp,
"logit" = plogis)
x <- as.matrix(x) # data
q <- as.matrix(q) # q-matrix
i <- nrow(x) # number of persons
j <- nrow(q) # number of items
k <- ncol(q) # number of skills
m <- 2^k     # number of attribute patterns in total
prep <- gdina_prepare(q, rule = rule, uniqueMj = ctrl$uniqueMj)
rule <- prep$rule
Mj <- prep$Mj
Kj <- prep$Kj
a <- prep$a
np <- prep$np
alphaeta <- prep$alphaeta
alphalg <- prep$alphalg
rownames(x) <- apply(x, 1, paste, collapse = "")
x_patt <- unique(x)
x_freq <- as.vector(table(rownames(x))[rownames(x_patt)])
names(x_freq) <- rownames(x_patt)
eq14 <- function(pj, xx)
{
pja <- t(sapply(1:j, function(jj) pj[[jj]][alphalg[,jj]]))
lxa <- .Call("calc_lxa", xx, pja, PACKAGE = "Rcdm")
rownames(lxa) <- rownames(xx)
colnames(lxa) <- rownames(a)
return(lxa)
}
posterior <- function(par, individuals = FALSE)
{
lxa <- eq14(par$pj, x_patt)
if(individuals) lxa <- lxa[rownames(x),]
# lxa <- t(exp(t(log(lxa)) + par$lprior))
# lxa / rowSums(lxa)
ll <- colSums(t(lxa) * par$pa)
t(t(lxa/ll) * par$pa)
}
loglik <- function(par)
{
lxa <- eq14(par$pj, x_patt)
sum(x_freq * log(colSums(t(lxa) * par$pa)))
}
E_step <- function(par)
{
post <- posterior(par) * x_freq
R <- I <- lapply(2^Kj, function(x) rep(NA, x))
for(jj in 1:j) {
rval <- post %*% alphaeta[[jj]]
I[[jj]] <- colSums(rval)
R[[jj]] <- colSums(rval * x_patt[,jj])
}
return(list(I = I, R = R, post = post))
}
EM <- function(par, eps = ctrl$eps.P)
{
## expectation
tval <- E_step(par)
## maximization
pj_upd <- lapply(1:j, function(jj) {
est <- tval$R[[jj]] / tval$I[[jj]]
est[is.nan(est)] <- eps
est
})
## avoid estimates on the boundary
pj_upd <- lapply(pj_upd, function(pj) {
pj[pj < eps] <- eps
pj[pj > 1 - eps] <- 1 - eps
pj
})
## estimate skill probabilities
pa_upd <- colSums(tval$post)/i
## avoid estimates on the boundary
pa_upd[pa_upd < eps] <- eps
pa_upd[pa_upd > 1 - eps] <- 1 - eps
pa_upd <- pa_upd / sum(pa_upd)
return(list(pj = pj_upd, pa = pa_upd))
}
## function to generate starting values
startvalues <- function(init = c(0.1, 0.9), random = FALSE, pj_init = NULL,
pa_init = NULL)
{
## item parameters
if(is.null(pj_init)) {
if(random) {
pj_init <- lapply(1:j, function(jj) {
lgjj <- nrow(prep$Mj[[jj]])
rval <- cumsum(runif(lgjj, ctrl$eps.P, 1 - ctrl$eps.P))
if(any(rval > 1)) rval/sum(rval) else rval
})
} else {
pj_init <- lapply(1:j, function(jj) {
lgjj <- nrow(prep$Mj[[jj]])
seq(init[1], init[2], length.out = lgjj)
})
}
}
## skill parameters
if(is.null(pa_init)) pa_init <- rep(1/m, m)
## names
names(pj_init) <- rownames(q)
names(pa_init) <- rownames(a)
# list(pj = pj_init, pa = pa_init, lprior = log(pa_init))
list(pj = pj_init, pa = pa_init)
}
pj2dj <- function(pj, I = NULL, method = ctrl$method, lambda = ctrl$lambda)
{
rval <- lapply(1:j, function(jj) {
Mjj <- Mj[[jj]]
Pjj <- pj[[jj]]
Wjj <- if(method == "WLS") I[[jj]] else rep(1, length(Pjj))
if(is.null(lambda)) {
Gjj <- Hjj <- NULL
np <- ncol(Mjj)
if(link == "identity") {
## linear predictor is between 0 and 1
Gjj <- Mjj
Hjj <- rep(2*ctrl$eps.P, nrow(Mjj))
Gjj <- rbind(Gjj, -Gjj)
Hjj <- c(Hjj, Hjj-1)
## constraint: intercept between 0 and 1
Gjj <- rbind(Gjj, c(1L, rep(0L, np-1)))
Hjj <- c(Hjj, 2*ctrl$eps.P)
Gjj <- rbind(Gjj, c(-1L, rep(0L, np-1)))
Hjj <- c(Hjj, 2*ctrl$eps.P-1)
## constraint: other parameters between -1 and 1
Gjj <- rbind(Gjj, diag(rep(1L, np))[-1,])
Hjj <- c(Hjj, rep(2*ctrl$eps.P-1, np-1))
Gjj <- rbind(Gjj, diag(rep(-1L, np))[-1,])
Hjj <- c(Hjj, rep(2*ctrl$eps.P-1, np-1))
}
if(link == "log") {
## linear predictor is below 0 -> response prob in (0,1)
Gjj <- -Mjj
Hjj <- rep(-linkfn(1 - 2*ctrl$eps.P), nrow(Mjj))
## constraint: parameters below 1
Gjj <- rbind(Gjj, diag(rep(-1L, np))[-1,])
Hjj <- c(Hjj, rep(2*ctrl$eps.P-1, np-1))
}
if(is.null(Gjj)) {
dj_est <- stats::lm.wfit(Mjj, linkfn(Pjj), Wjj, offset = NULL)$coefficients
} else {
Ajj <- diag(sqrt(Wjj)) %*% Mjj
Bjj <- diag(sqrt(Wjj)) %*% linkfn(Pjj)
dj_est <- limSolve::lsei(A = Ajj, B = Bjj, G = Gjj, H = Hjj, type = 2)$X
}
## lm.fit produces NA values, when the system is (nearly) singular. This
## happens, when two estimates are identical. Then, try to compute
## estimates manually:
naTRUE <- any(is.na(dj_est))
useoptim <- ctrl$useoptim
if(naTRUE) useoptim <- TRUE
if(rule[jj] == "ACDM") useoptim <- TRUE
if(useoptim) {
if(naTRUE) {
dj_init <- startvalues()$dj[[jj]]
} else {
dj_init <- dj_est
}
Hjj <- Hjj - ctrl$eps.P
dj_est <- optim_par(Mjj = Mjj, Pjj = Pjj, Wjj = Wjj, ui = Gjj, ci = Hjj, dj_init = dj_init)
}
} else {
out <- glmnet::glmnet(Mjj, Pjj, family = "gaussian", weights = Wjj, lambda = lambda)
dj_est <- coef(out)[-2,]
}
dj_est
})
names(rval) <- names(pj)
rval
}
optim_par <- function(Mjj, Pjj, Wjj, ui, ci, dj_init)
{
Wjj12 <- diag(sqrt(Wjj))
fn <- function(dj) sum((Wjj12 %*% (linkfn(Pjj) - Mjj %*% dj))^2)
gradfn <- function(dj) sum(t(Wjj12 %*% (linkfn(Pjj) - Mjj %*% dj)) %*% (Wjj12 %*% Mjj))
if(is.null(ui)) {
out <- optim(dj_init, fn, method = "L-BFGS-B", control = list(maxit = 100))
} else {
out <- constrOptim(theta = dj_init, f = fn, grad = gradfn, method = "BFGS",
ui = ui, ci = ci, control = list(maxit = 100))
}
out$par
}
par_upd <- startvalues(random = ctrl$init.random, pj_init = ctrl$init.pj,
pa_init = ctrl$init.pa)
diff <- 1
hist <- list(pj = unlist(par_upd$pj), pa = unlist(par_upd$pa))
iter <- 1
mGDINA$parhist
mGDINA$parhist[1,]
mGDINA$parhist$pj[1,]
mACDM$parhist$pj[1,]
mDINA <- gdina(xx$resp, qmat, rule = "DINA")
x11()
plot(mDINA)
mDINA$parhist$pj[1,]
mDINA$prep$Kj
mDINA$prep$alphaeta
mGDINA$prep$alphaeta
mACDM$prep$alphaeta
mGDINA$prep$alphaeta$b112
mACDM$prep$alphaeta$b112
mGDINA$prep$alphaeta$b112
mACDM$prep$alphaeta$b112
mGDINA$prep$alphaeta$b112 == mACDM$prep$alphaeta$b112
mDINA$prep$alphaeta
mDINA$prep$alphaeta$b112
mGDINA$prep$alphaeta$b112
mACDM$prep$alphaeta$b112
mDINA$I
mDINA$I$b112
mGDINA$I$b112
mACDM$I$b112
mGDINA$prep == mACDM$prep
all.equal(mGDINA$prep, mACDM$prep)
mGDINA$Mj
mGDINA$prep$Mj$b112
mACDM$prep$Mj$b112
mACDM$prep$Aj
mACDM$prep$Mj
mACDM$prep$a
mACDM$prep$alphaeta
mACDM$prep$alphalg
mACDM$dj
mACDM$dj$b112
mGDINA$dj$b112
xx <- gdina_sim(1000, qmat, rule = "G-DINA")
mGDINA <- gdina(xx$resp, qmat)
mACDM <- gdina(xx$resp, qmat, rule = "ACDM")
mDINA <- gdina(xx$resp, qmat, rule = "DINA")
xx <- gdina_sim(1000, qmat, rule = "G-DINA")
mGDINA <- gdina(xx$resp, qmat)
mACDM <- gdina(xx$resp, qmat, rule = "ACDM")
mDINA <- gdina(xx$resp, qmat, rule = "DINA")
mGDINA$pj$b112
mACDM$pj$b112
mDINA$pj$b112
source('~/Dropbox/UZH/Forschung/CDM/GitHub/Rcdm/R/gdina.R')
source('~/Dropbox/UZH/Forschung/CDM/GitHub/Rcdm/R/gdina.R')
xx <- gdina_sim(1000, qmat, rule = "G-DINA")
mGDINA <- gdina(xx$resp, qmat)
mACDM <- gdina(xx$resp, qmat, rule = "ACDM")
mDINA <- gdina(xx$resp, qmat, rule = "DINA")
mGDINA$pj$b112
mACDM$pj$b112
mDINA$pj$b112
mGDINA$dj$b112
mACDM$dj$b112
mDINA$dj$b112
mGDINA$loglik
mACDM$loglik
mDINA$loglik
library("Rcdm")
data("probability", package = "pks")
items <- sprintf("b1%.2i", 1:12)
resp <- probability[, items]
resp <- resp[complete.cases(resp),]
qmat <- read.table(header = TRUE, text = "
cp id pb un
0  0  1  0
1  0  0  0
0  0  0  1
0  1  0  0
1  0  1  0
1  0  1  0
0  0  1  1
0  0  1  1
0  1  1  0
1  1  0  0
1  1  1  0
0  1  1  1
")
rownames(qmat) <- colnames(resp)
## fit model
mGDINA <- gdina(resp, qmat)
coef(mGDINA)
mDINA <- gdina(resp, qmat, rule = "DINA")
mDINO <- gdina(resp, qmat, rule = "DINO")
mACDM <- gdina(resp, qmat, rule = "ACDM")
anova(mDINA, mACDM, mGDINA)
AIC(mDINA, mDINO, mACDM, mGDINA)
BIC(mDINA, mDINO, mACDM, mGDINA)
AIC(mDINA, mDINO, mACDM, mGDINA)
AIC(mDINA, mDINO, mACDM, mGDINA)
BIC(mDINA, mDINO, mACDM, mGDINA)
anova(mDINA, mACDM, mGDINA)
anova(mDINO, mACDM, mGDINA)
AIC(mDINA, mDINO, mACDM, mGDINA)
BIC(mDINA, mDINO, mACDM, mGDINA)
gdina_wald(mGDINA)
